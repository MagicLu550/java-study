#1、阻塞和非阻塞
###1.1 阻塞和非阻塞：阻塞和非阻塞是进程访问数据时，数据是否准备就绪的一种处理方式。当数据没有准备好时，阻塞往往需要等待缓冲区中的数据准备好后，在处理其他事情，否则想吃一直等待。
###1.2 非阻塞：当线程访问数据缓冲区时，数据没有准备好，线程直接返回，不需要等待；如果数据准备好也直接返回。

#2、同步与异步
###同步和异步都是给予应用程序和操作系统处理IO时间采用的方式；例如同步：应用系统直接参与IO读写的操作。异步：所有的IO读写都交给操作系统来执行。同步方式在处理IO事件时，必须阻塞在某个方法上，等待我们的IO时间完成（阻塞IO事件，或者轮训IO事件的方式）。对于异步来说，所有的IO操作都交给操作系统来完成，我们可以去做其他的事情，并不需要去完成真正的IO。

###2.1 同步阻塞IO：阻塞IO事件，阻塞Read或者Write方法，这时线程一直等待，不能做其他事情。实现方式：让读写方法加入到线程中，阻塞线程。系统开销比较大。
###2.2 同步阻塞IO事件轮训（Linux的多路复用技术select）：读写事件交个一个单独的线程来处理，这个线程完成IO事件的注册，并且不断轮训需要读写的缓冲区，判断是否有数据准备好，如果有数据准备好，就通知对应的读写线程。这样读写线程可以做其他事情，这时阻塞的不是所有的线程，而是只有select这一个线程。

#3、JAVA IO模型
###3.1 BIO：JDK 1.4之前我们使用的IO，都是BIO，阻塞IO；阻塞到我们的读写方法中。
###3.2 NIO：JDK 1.4 Linux 多路复用技术(Select 模型)，实现IO事件的轮训方式，同步非阻塞的模式，这种方法是目前主流的网络通信模式；Mina、Netty、等通信框架。
###3.3 AIO：JDK 1.7才实现了真正的AIO，学习Linux epoll模式。

#4、总结
###4.1 BIO阻塞的IO
###4.2 NIO 同步非阻塞
###4.3 AIO 异步非阻塞


