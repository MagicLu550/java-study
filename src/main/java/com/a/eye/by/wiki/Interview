一、导致服务器频繁fullGC的原因有那些？
二、限流算法
1、在高并发的系统中，缓存、降级、限流是三把利器。
2、限流就是限制流量，很好的控制系统的qps，从而达到保护系统的作用。
3、限流的方法
1）计数器：计数器是最简单最容易实现的算法。设置一个计数器counter，没当一个请求过来的时候，counter加1，如果counter的值大于100，并且
请求与第一个请求的间隔时间在1分钟以内，那么说明请求数过多。算法简单，最容易出现的是临界值问题。
2）滑动窗口：滑动窗口为了解决临界值问题，很多个矩形框组成时间窗口，每个时间窗口是1分钟，将滑动窗口划分为6个格子，每个格代表10秒钟，没过
10秒钟，格子向右滑动一格，每个各自有自己的counter。滑动窗口划分的格子越多，滑动窗口的滚动就越平滑，限流的统计就越精确。
3）漏桶算法：有个固定容量的桶，有水流进来，也有水流出去，对于进来的水，无法估量有多少，水流的速度也无法估计，但是对于流出去的水来说，可以固定流出的频率。而且
当桶满后，多余的水会流出去。
我们将算法中的水换成实际应用中的请求，我们可以看到漏桶算法天生就限制了请求的速度。当使用了漏桶算法，我们可以保证接口会以一个常速速率来处理请求。所以漏桶算法天生不会出现临界问题。
4）令牌桶算法：令牌桶算法比漏桶算法稍显复杂。首先，我们有一个固定容量的桶，桶里存放着令牌（token）。桶一开始是空的，token以 一个固定的速率r往桶里填充，直到达到桶的容量，多余的令牌将会被丢弃。
每当一个请求过来时，就会尝试从桶里移除一个令牌，如果没有令牌的话，请求无法通过。
我们会发现我们默认从桶里移除令牌是不需要耗费时间的。如果给移除令牌设置一个延时时间，那么实际上又采用了漏桶算法的思路。Google的guava库下的SmoothWarmingUp类就采用了这个思路。

Java实现
我们可以使用Guava 的 RateLimiter 来实现基于令牌桶的流控，RateLimiter 令牌桶算法是单桶实现。RateLimiter 对简单的令牌桶算法做了一些工程上的优化，具体的实现是 SmoothBursty。
需要注意的是，RateLimiter 的另一个实现SmoothWarmingUp，就不是令牌桶了，而是漏桶算法。也许是出于简单起见，RateLimiter 中的时间窗口能且仅能为 1s。
SmoothBursty 有一个可以放 N 个时间窗口产生的令牌的桶，系统空闲的时候令牌就一直攒着，最好情况下可以扛 N 倍于限流值的高峰而不影响后续请求。
RateLimite允许某次请求拿走超出剩余令牌数的令牌，但是下一次请求将为此付出代价，一直等到令牌亏空补上，并且桶中有足够本次请求使用的令牌为止。
当某次请求不能得到所需要的令牌时，这时涉及到一个权衡，是让前一次请求干等到令牌够用才走掉呢，还是让它先走掉后面的请求等一等呢？Guava 的设计者选择的是后者，先把眼前的活干了，后面的事后面再说。
三、线程池排队策略
1、直接提交：工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。
当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。
2、无界队列：使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。
（因此，maximumPoolSize 的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；
3、有界队列：有界队列。当使用有限的 maximumPoolSizes 时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：
使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。
四种预定义的处理程序策略:
在默认的 ThreadPoolExecutor.AbortPolicy 中，处理程序遭到拒绝将抛出运行时RejectedExecutionException。
在 ThreadPoolExecutor.CallerRunsPolicy 中，线程调用运行该任务的execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。
在 ThreadPoolExecutor.DiscardPolicy 中，不能执行的任务将被删除。
在 ThreadPoolExecutor.DiscardOldestPolicy 中，如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）。

四、除了kv类型的数据存储外，redis适合的业务场景
五、如果解决写操作跨库的数据一致性问题
六、spring aop如何实现，两种的区别，描述一下java动态代理的实现
七、什么是乐观锁，乐观锁的机制是什么，
八、线程通信
线程间通信和同步的方式主要有锁、信号、信号量
进程间的通信：通信机制主要有：管道、有名管道、消息队列、信号量、共享空间、信号、套接字（socket）
java线程通信 wait、notify、notifyAll、concurrent包lock下的condition里的await、signal、signalALl方法





