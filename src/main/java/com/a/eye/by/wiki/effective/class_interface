十三、使类和成员的可访问性最小
1、尽可能使每个类或者成员不被外接访问
2、类的访问级别
	私有的：只有声明该成员的顶层类内部才可以访问这个成员
	包级私有的，声明该成员所在的包内部的任何类都可以访问这个成员。被成为缺省的访问级别。
	受保护的：声明该成员的子类可以访问这个成员，声明该成员的包内部的任何类也可以访问此成员。
	公有的：任何地方都可以访问
3、实例域绝不能是公有的。
总结：应该始终尽可能的降低可访问性，应该防止把任何散乱的类、接口和成员变成API的一部分，除了公有静态final域特殊情况除外，公有类都不应该
有公有域，并且要确保公有静态final域所引用的对象都是不可变的。

十四、在公有类中使用访问方法而非公有域
1、如果类可以在它所在的包的外部进行访问，提供访问方法。
2、如果类是包级私有的，或者是私有的嵌套类，直接暴露它的数据域并没有本质的错误。
3、共有类不应该直接暴露数据域

十五、使可变性最小
1、类不可变的规则
	1、不要提供任何会修改对象状态的方法。
	2、保证类不会被扩展。一般做法是使类变成final的。
	3、所使用的域都是final的。
	4、所使用的域都是私有的
	5、确保对于任何可变组件的互斥访问
2、不可变对象本质是线程安全的，不需要同步
3、不可变对象可以自由的共享
4、不可变对象为其他对象提供了大量的构件
5、不可变对象唯一的缺点是，对于每个不同的值都需要一个单独的对象。
	
十六、复合优先于继承
1、与方法调用不同，继承打破了封装性。
2、继承的功能非常强大，但是也有很多问题，只有当子类和超类之间确实存在类型关系时，使用继承才恰当。如果处在不同的包，并且超类并不是为了继承而设计的，那继承将会变得很脆弱。

十七、要么为继承而设计，并提供文档说明，要么就禁止继承

十八、接口优于抽象类
1、现有的类很容易被更新，以实现新的接口。
2、接口是定义混合型的理想选择。
3、接口允许我们构造非层次结构类型的框架。
4、通过对你导出的每个重要接口都提供一个抽象的骨架实现类，把接口和抽象类的优点结合起来。

十九、接口只用来定义类型
1、常量接口模式是对接口的不良使用

二十、类层次优于标签类
1、标签类过于冗长、容易出错、并且效率低下。
2、标签类是类层次的一种简单的效仿
3、类层次容易扩展
4、类层次可以反应类型本质上的层次关系，更加灵活

二十一、用函数对象表示策略
函数指针的主要作用就是实现策略模式，声明一个接口来标识该策略，并且为每个具体策略声明实现了该接口的类。
当一个策略只被使用一次时，通过使用匿名内部类和实例化这个策略。当一个策略用来重复使用时，它的类通常要被实现为私有地静态的成员类，并通过静态的
final域被导出，其类型为该策略的接口。

二十二、优先考虑静态成员类
1、嵌套类是定义在另外一个类中的内部类，目的是为了它的外围类提供服务。
2、嵌套类有4种
	静态成员类
	非静态成员类
	匿名类
	局部类
3、静态成员类，是最简单的一种嵌套类，声明在另外一个类的内部，它可以访问外围类的所有成员，包括生命为私有的成员。静态成员类是外围类的一个成员，和其他静态成员一样。
也遵守同样的可访问性规则。如果它被生命为私有的，只能在外围类的内部可以被访问。
静态成员类的常用方法是作为公有类的辅助类，仅当与它的外部类一起使用时才有意义。
4、非静态成员类：非静态成员类的每个实例都隐含着与外围类的一个外围实例相关联。非静态成员类的实例方法，可以调用外围类的实例方法。
当非静态成员类的实例被创建时，它和外围类的实例就建立了关系。
5、如果声明的成员类不要求访问外围实例，就要始终把static修饰符放在它的生命中，使他成为静态成员类。
总结：如果成员类的每个实例都需要指向其外围实例的引用，就要把成员类做成非静态的。否则就做成静态的。















