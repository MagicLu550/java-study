一、redis数据类型
1、string、list、set、zset、hash
2、String是最简单的类型，一个key对应一个value
3、list是一个链表，主要包括push、pop，获取一定范围内的所有值，操作中key为链表的名称
4、set是集合，对集合的操作包括，新增、删除、合并求交集等，操作中的key为集合的名称。
5、zSet是set的一个升级版本，在set的基础上增加了顺序的功能，这个属性在添加删除的时候可以指定，每次指定后，zSet会自动重新按照
新的值调整顺序。
6、Hash数据类型允许用户使用redis对象类型，当你存储的数据对象只有很少几个key值时，数据存储的消耗会很小。

二、Redis的持久化方式：
1、RDB方式：默认redis会以快照的形式存储数据持久化到硬盘中，在配置文件中的格式是 save N M，标识在N秒的时间内，redis至少发生
M次修改，则将redis抓去快照到磁盘。工作原理：当redis需要做持久化时，只需要fork一个子进程，子进程将数据写入到磁盘上的一个临时
文件RDB中，当子进程完成后，将原来的RDB文件替换掉，这样的好处是copy-on-write。
2、AOF方式：append only file，文件日志追加，当开启后，redis每执行一次修改数据的命令后，都会把它添加到aof文件中，当redis
重启时，进行"重放"，以恢复redis关闭前的最后时刻。AOF的三中方式：每提交一个修改命令都刷新到aof中，非常慢，但是很安全。每秒中
刷盘一次，很快，但是可能会丢失一秒中的数据。第三种是依赖操作系统的缓存进行刷新，最快，但是安全性最差。

三、Redis各种特征的试用场景
1、Strings
Strings 数据结构是简单的key-value类型，value其实不仅是String，也可以是数字。
setnx 设置可以为对应的值为String类型的value，如果key存在返回0不覆盖，不存在返回1
常规key-value缓存应用。
常规计数: 微博数, 粉丝数
2、Hashs
在Memcached中，我们经常将一些结构化的信息打包成hashmap，在客户端序列化后存储为一个字符串的值，比如用户的昵称、年龄、性别、积分等，这时候在需要修改其中某一项时，
通常需要将所有值取出反序列化后，修改某一项的值，再序列化存储回去。这样不仅增大了开销，也不适用于一些可能并发操作的场合（比如两个并发的操作都需要修改积分）。
而Redis的Hash结构可以使你像在数据库中Update一个属性一样只修改某一项属性值。
它是一个String类型的field和value的映射表，它的添加和删除都是平均的，hash特别适合用于存储对象，对于将对象存储成字符串而言，hash会占用更少的内存，
并且可以更方便的存取整个对象. 它和java的HashMap完全类似
使用场景
存储部分变更数据
如用户信息等。
3、Lists
Lists 就是链表，略有数据结构知识的人都应该能理解其结构。使用Lists结构，我们可以轻松地实现最新消息排行等功能。Lists的另一个应用就是消息队列，可以利用Lists的PUSH操作，将任务存在Lists中，
然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作Lists中某一段的api，你可以直接查询，删除Lists中某一段的元素。
Redis的list是每个子元素都是String类型的双向链表，可以通过push和pop操作从列表的头部或者尾部添加或者删除元素，这样List即可以作为栈，也可以作为队列。
消息队列系统
使用list可以构建队列系统，使用sorted set甚至可以构建有优先级的队列系统。
比如：将Redis用作日志收集器
实际上还是一个队列，多个端点将日志信息写入Redis，然后一个worker统一将所有日志写到磁盘。
取最新N个数据的操作
记录前N个最新登陆的用户Id列表，超出的范围可以从数据库中获得。
//把当前登录人添加到链表里
ret = r.lpush("login:last_login_times", uid)
//保持链表只有N位
ret = redis.ltrim("login:last_login_times", 0, N-1)
//获得前N个最新登陆的用户Id列表
last_login_list = r.lrange("login:last_login_times", 0, N-1)
比如sina微博：
在Redis中我们的最新微博ID使用了常驻缓存，这是一直更新的。但是我们做了限制不能超过5000个ID，因此我们的获取ID函数会一直询问Redis。只有在start/count参数超出了这个范围的时候，才需要去访问数据库。
我们的系统不会像传统方式那样“刷新”缓存，Redis实例中的信息永远是一致的。SQL数据库（或是硬盘上的其他类型数据库）只是在用户需要获取“很远”的数据时才会被触发，而主页或第一个评论页是不会麻烦到硬盘上的数据库了。
Sets
Sets 就是一个集合，集合的概念就是一堆不重复值的组合。利用Redis提供的Sets数据结构，可以存储一些集合性的数据。
案例：
在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，
你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。
Set是集合，是String类型的无序集合，set是通过hashtable实现的，概念和数学中个的集合基本类似，可以交集，并集，差集等等，set中的元素是没有顺序的。

Sorted Sets
和Sets相比，Sorted Sets增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，比如一个存储全班同学成绩的Sorted Sets，其集合value可以是同学的学号，而score就可以是其考试得分，
这样在数据插入集合的时候，就已经进行了天然的排序。
可以用Sorted Sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。
比如在线游戏的排行榜，根据得分你通常想要：
- 列出前100名高分选手
- 列出某用户当前的全球排名






