八、覆盖equals时遵守通用约定
• equals特性：
1、自反性，对于任何非null的引用值x，x.equals(x)必须返回true
2、对称性，对于任何非null的引用值x、y。当且仅当x.equals(y)返回true，并且y.equals(x)必须返回true
3、传递性：
4、一致性：对于非null的引用值x，y，只要equals的比较操作在对象所有信息没有被修改过，多次调用的结果是一致的。
5、对于任何非null的引用值x，x.equals(null),必须返回false

• 实现高质量equals方法的诀窍
1、使用==操作符检查，"参数是否为这个对象的引用"，如果是返回true
2、使用instanceof 操作符检查"参数是否为正确的类型"，如果不是则返回false。
3、把参数转换成正确的类型
4、对于该类中的每个关键域，检查参数中的域是否与该对象中对应的域匹配。
总结，对于既不是float和double类型的基本数据类型，可以使用==操作符进行比较，对于对象引用，可以递归的调用equals方法，对于float、double
域进行特殊处理是有必要的。域的比较顺序可能影响性能，应该优先比较最不可能一致的域。

• 覆盖equals方法的一些告诫
1、覆盖equals方法总要覆盖hashcode方法
2、不要企图让equals方法过于智能
3、不要将equals声明中的object对象替换成其他类型。

九、覆盖equals方法总要覆盖hashCode方法
1、在每个覆盖了equals方法的类中，必须覆盖hashCode方法。
2、相等的对象必须具有相等的散列码hashCode
3、不要视图从一个散列码计算中排除一个对象的关键部分来提高性能。

十、始终要覆盖toString方法
1、提供好的toString方法可以使类使用起来更加舒适
2、toString方法返回对象中所有值得关注的信息
3、toString返回值中包含的信息，提供一种编程式的访问途径。

十一、谨慎的覆盖clone方法
所有实现了cloneable接口的类都应该有一个共有的方法覆盖clone，此公有方法首先调用super.clone,然后修正任何需要修正的域。一般情况下，这意味需要拷任何包含内部"深层结构"的可变对象，并指向新对象的引用来替换原来
指向这些对象的引用。

十二、考虑实现comparable接口
compareTo方法并不是Object中生声明，它是comparable接口中的唯一方法，compareTo可以进行简单的等同性比较，而且允许顺序比较。
对象之间的比较，当对象大于、小于、等于指定对象时，分别返回一个正数、零、负数。