一、Cpu与内存
1、Cpu是一块超大规模集成电路板，是计算机的核心部件。CPU包括：控制器、运算器、寄存器；
2、控制器组成：控制单元、指令译码器、指令寄存器组成；控制单元是CPU的大脑，由时序控制器和指令控制器组成；指令译码器是在控制单元的协调下完成指令读取，
分析并交由运算器执行；指令寄存器是存成指令集，当前流行的指令集包括：X86，SSE，MMX等。
3、运算器：核心是算术逻辑运算单元，ALU，能执行算术运算或逻辑运算等各种指令。运算单元会从寄存器中提取或者存储数据。
4、寄存器：最著名的寄存器是CPU的高速缓存L1、L2，缓存容量是在组装计算机逼问的CPU性能问题之一；CPU缓存部分指令和数据，以提升性能；
5、L0寄存器、L1一级缓存、L2二级缓存、内存、本地磁盘、分布式存储、云端存储；
二、TCP、IP协议
1、传输控制协议/因特网互联协议。是当前流行的网络传输协议框架。
2、OSI模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层；
三、影响RPC性能的因素如下：
1、序列化。常用的RPC序列化协议包括：Thrift、Protobuf、Avro、Kryo、MsgPack、Hessian、Jackson。
2、传输协议。常用的传输协议包括：HTTP、Socket、TCP、UDP等；
3、连接。连接包括：长连接、短链接；
4、IO模型。常用的网络IO模型：同步阻塞IO、同步非阻塞IO、IO多路复用、异步IO；
注释：stub一般翻译成存根，即在本地存在一个和远程一样的方法；
四、Protobuf
protobuf是一个高性能、易扩展的序列化框架，通常是rpc调用追求高性能的首选。结合Netty可以非常便捷的实现RPC调用。Protobuf比JSON、XML更快、更轻、更小
，并且可以跨平台。Protobuf首先要编写proto文件，即IDL文件，后缀为“.proto”的文件。然后通过客户端生成Java相关类进行序列化、反序列化。
五、Rest
Rest是Representaitional State Transfer的缩写，通常翻译成“表现层状态转换”；
1、协议：API基于HTTP协议；
2、域名：需要一个域名例如：http://api.xx.com;
3、版本：需要版本信息，例如http://api.xx.com/v1/
4、路径：rest开发又被称作是面向资源的开发。例如http://api.xx.com/v1/user/
5、方法：一般包含的方法包括：get（获取资源，一个或者多个）；post（创建资源）；put（修改资源，客户端提供修改后的完整资源）；
patch（对已知资源进行全局更新，客户端需要提供改变的属性）；delete（删除，回收资源）；head（获取资源的元数据）；option（读取对资源的访问权限）；
注释：SLA：需要提供相应时间、吞吐量、可用性等关键指标；
六、HTTP/2协议
HTTP/2对比HTTP/1.x进行了大量简化，使得性能大幅提升；HTTP/2是基于二进制协议的。
HTTP/1.x的语义只支持客户端发起请求，服务端响应数据。HTTP/2改变了这种模式，只需要客户端发送一次请求，服务端便把所有的资源都推送到客户端。
七、Cloud Native属性总结
分布式、弹性、多租户、自服务、按需计量和计费、增量部署和测试；
八、gRPC
1、gRPC默认使用Protobuf进行序列化和反序列化。
2、gRPC默认采用HTTP/2进行传输。HTTP/2支持流（streaming），在批量发送数据的场景下使用流可以显著提升性能；
3、gRPC流可以分为三类：客户端流式发送、服务端流式返回、客户端/服务端同时流式处理；
4、gRPC并非完美，相比非IDL描述的RPC（Hession、Kyro）方式，定义proto文件是一个比较麻烦的事情。另外HTTP/2相比于基于TCP的通信协议，心梗也有显著的差异；
九、微服务框架
服务治理、容量规划、高效通信（需要微服务框架实现高效的序列化、反序列化、支持并行、异步、非阻塞转换以及多语言支持）、负载均衡（微服务框架需要支持常用
负载均衡、故障转移、支持自由的流量切换）；
十、Dubbo
1、Dubbot中的角色：Provider提供者，Consumer消费者、Registry注册中心、Montiro监控中心。
2、消费者启动后，会查询注册中心，注册中心返回提供者地址列表给消费者。如果有变更，注册中心将以长连接推送变更数据给消费者。
十一、Etcd
Etcd是一个高可用的键值存储系统，主要用于共享配置和服务发现。它使用Go语言编写，并通过Raft一致性算法处理日志复制以保障强一致性。Etcd并不是强一致的。
十二、微服务部署策略
服务独享数据库、服务独享虚拟机/容器；
十三、容器VS虚拟机
虚拟机是在硬件的基础上进行虚拟化，隔离性更高，而容器是在操作系统上进行的虚拟化。容器更像软件中的集装箱，能够把环境、配置、依赖、软件等封装起来。
Docker可以让开发者大宝应用及依赖包到一个轻量级、可移植的容器中，然后发布到任何安装了Docker的物理机或者虚拟机上，而不必担心是否安装了依赖项，
不必考虑编译器或其他任何需要支持的基础设施；
十四、分布式消息中间件
通过分布式消息中间件解耦。系统之间可以进行可靠的异步通信，从而降低系统之间的耦合度，系统能够得到更好的扩展性和可用性。通过分布式消息中间件降低响应
时间。通过分布式消息中间件提升吞吐率。
十五、Kafka的设计原理
在Kafka中，消息被持久化到磁盘，Kafka需要依赖于ZooKeeper管理元数据。
Borker：Kafka的服务端，负责接收数据，并持久化数据，Broker可以有多个，每隔Broker可以包含多个Topic，Broker并不保存Offset数据，由Consumer自己
负责保存，默认保存在Zookeeper中。
Producer：生产者，生成数据发送到Broker存储数据，Producer将会和Topic下所有Partition Leader保持连接。
Consumer：消费者，每个Partition只能被一个消费者订阅，一个消费者可以订阅多个Partition，消费者挂掉后会从新进行负载均衡。
Topic：主题，每个Topic包含多个Partition，所有的元数据都存储在ZooKeeper中。
Partition：分区，Kafka为了扩展性，可以将一个Topic拆分为多个分区，每个分区可以独立放到一个Broker上。














