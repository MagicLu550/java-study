一、字节流：
1、字节流可以处理一切（文本、音频、视频）
2、输入流 InputStream FileInputStream ByteArrayInputStream ObjectInputStream BufferedInputStream FilterInputStream DataInputStream
3、操作read字节数组
中间容器 byte[] flush = new byte[长度]，接收长度 int len = 0，循环读取while(-1!=(len=流.read(flush)))。输出拷贝
4、输出流 OutputStream FileOutputStream ByteArrayOutputStream ObjectOutputStream BufferedOutputStream DataOutputStream
5、操作write(字节数组,0,长度)

二、字符流
1、字符流，只能处理纯文本
2、输入流 Reader FileReader
3、操作read（字符数组）
4、中间容器 byte[] flush = new byte[长度]，接收长度 int len = 0，循环读取while(-1!=(len=流.read(flush)))。输出拷贝
5、输出流：Writer FileWriter
6、操作write(字节数组,0,长度)

三、字节流和字符流转换
1、输入流 InputStreamReader 解码
2、输出流 OutputStreamWriter 编码

四、缓冲流
1、输入流：BufferedInputStream BufferedReader
2、输出流：BufferedOutputStream BufferedWriter

五、处理数据+类型
1、输入流：DataInputStream readXxx
2、输出流：DataOutputStream writeXxx
3、引用类型
3.1 反序列化 ObjectInputStream readObject
3.2 序列化 ObjectOutputStream wirteObject

六、打印流：PrintStream

七、IO流分类
1、基于字节操作的IO接口：InputStream、OutputStream
2、基于字符操作的IO接口：Reader、Writer
3、基于磁盘操作的IO接口：File
4、基于网络操作的IO接口：Socket

八、字节和字符转换
1、InputStreamReader：从字节流转换成字符流，转换是需要指定编码格式，否则很容易出现乱码，StreamDecoder正是完成字节到字符的解码实现类。
2、OutputStreamWriter：从字符流转换成字节流，由StreamEncoder完成编码过程。

九、磁盘IO工作机制：
9.1几种访问文件的方式：
1、标准访问文件方式：
read接口，首先读取用户地址空间的缓存是否存在，如果存在直接返回，如果不存在，读取内核空间的高速页缓存，如果没有则读取磁盘空间。
write接口，首先将数据从用户地址空间复制到内核地址空间的缓存中，这时对用户来说操作已经完成，至于什么时候写入磁盘由操作系统决定，也可以调用sync同步完成。
2、直接IO访问方式：就是应用程序直接访问磁盘，不经过操作系统内核数据缓存区，目的为了减少一次从内核缓冲区到用户缓冲区数据的复制。例如数据库管理系统。操作系统很难知道哪些是热点数据，操作系统
只是简单的缓存最近一次从磁盘读取的数据。直接IO访问数据，如果不在应用程序缓存中，那么每次直接从磁盘加载，会非常慢。
read接口：首先读取用户地址空间的缓存，如果有直接返回，没有则直接访问磁盘空间。
write接口：首先写入应用地址空间的缓存，然后再写入磁盘空间。
3、同步访问文件方式：同步访问文件的方式就是数据的读取和写入都是同步操作的，与标准访问文件方式不同的是，只有当数据被成功写入到磁盘时，才返回给应用程序成功的标识。
这种访问方式性能比较差，只有在一些对数据安全要求比较高的场景才使用。
4、异步访问文件方式：当访问数据的线程发出请求后，线程会继续处理其他事情，而不是阻塞等待，当请求的数据返回后继续处理下面的操作。这种访问方式明显提高应用程序的效率，但是不会改变访问文件的效率。
5、内存映射的方式：内存映射是操作系统将内存中的某一个区域与磁盘中的文件关联起来，当要访问内存中的一段数据时，转换成访问文件的某一段数据，这种方式的目的是同样减少数据从内核空间缓存到用户空间的数据
复制操作，因为这两个空间的数据是共享的。
9.2java访问磁盘文件：
java中通常的File并不代表是一个真是存在的文件对象，当你指定一个路径描述符时，它就会返回一个代表这个路径的虚拟对象，可能是一个真是存在的文件或者是一个包含多个文件的目录。FileDescriptor对象，就是
真正代表一个存在文件对象的描述。
9.3 JAVA序列化：
1、概念：将一个对象转换成一串二进制表示的字节数组，通过保存或者转意这些字节数据来达到持久化的目的，需要持久化就必须实现java.io.Serializable接口。反序列化时，必须有原始类作为模板，才能将对象还原。
2、java序列化的一些总结
2.1:当父类序列化时，所有子类都可以被序列化。
2.2:子类实现Serializable接口，父类没有，父类中的属性不会序列化（不报错，数据会丢失）
2.3：如果序列化的属性是对象，则这个对象必须实现Serializable接口，否则会报错。
2.4：在反序列化是，如果对象的属性有修改或者删除，则修改的部分属性会丢失，但是不会报错。
2.5：在反序列化时，如果serialVersionUID被修改，那么反序列化时会失败。

十、影响网络传输的因素：
1、网络带宽：一条物理链路上在1s内能够传输的最大比特数。
2、传输距离：也就是数据在光纤中要走的距离，数据在光纤中移动并不是直线，所以有一个折射率，大概是光的2/3，这段时间也就是我们常说的网络延迟。
3、TCP拥塞控制：

十一、BIO、NIO、AIO
1、IO的方式通常分为几种，同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO
2、同步阻塞IO（JAVA BIO）： 
同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，
当然可以通过线程池机制改善。
3、同步非阻塞IO(Java NIO) ： 
同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。
4、异步阻塞IO（Java NIO）：
此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，
那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄（如果从UNP的角度看，select属于同步操作。
因为select之后，进程还需要读写数据），从而提高系统的并发性！
5、Java AIO(NIO.2)）异步非阻塞IO: 
在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，
因为真正的IO读取或者写入操作已经由内核完成了。

十二、BIO、NIO、AIO适用场景分析: 
1、BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。 
2、NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。 
3、AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。













































