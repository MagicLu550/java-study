一、微服务故障
1、分布式调用故障
	序列化、反序列化故障
	分布式路由故障
	网络通信故障
2、第三方服务故障，微服务会依赖第三方服务，包括数据库服务、文件存储服务、缓存服务、消息队列服务等
	网络通信类故障
	雪崩效应，导致的级联故障，例如服务处理缓慢导致客户端线程被阻塞
	第三方不可用，导致微服务处理失败
3、微服务之间的故障
	处理较慢的微服务会阻塞其他服务
	某个微服务故障蔓延，导致整个进程不可用OOM
	低优先级的微服务，抢占高优先级微服务的资源
	
二、服务故障隔离
1、IO操作故障隔离：网络IO、磁盘IO、数据库
2、资源故障隔离
	通信链路隔离
	调度资源隔离：微服务之间隔离、第三方依赖隔离
	进程级隔离：VM隔离、进程级隔离
3、容错能力
	路由容错：失败重试、失败回调、快速失败
	服务降级：强制降级、容错降级
	熔断：全部拒绝、部分拒绝
4、流量控制

三、故障隔离技术
同步I/O主要弊端:
I/O操作同步阻塞, 受制于网络和第三方处理速度  I/O线程效率低,容易发生 线程数量膨胀、通信队列积压 等问题
优化策略:
TCP私有协议:建议直接基于 Netty开发
HTTP/Restful/SOAP等:选择支 持非阻塞I/O的Web框架。可以选 择基于Netty构建的开源应用层 协议栈框架

四、RPC通信链路隔离
隔离策略:
1、微服务节点之间支持配置多链路
2、微服务链路支持不同的隔离策略: 例如根据消息码流大小、根据微服务的优先级等策略,实现链路级的隔离

五、微服务调度隔离
关键技术点:
1、微服务发布时支持指定线程池/线程组
2、微服务线程池支持独享和共享两种模式  微服务和线程池监控,识别故障微服务, 动态调整到故障隔离线程池中
3、支持按照微服务优先级调度微服务, 即微服务线程支持微服务优先级调度

六、第三方服务依赖隔离
关键技术点:
1、第三方依赖隔离可以采用线程池 + 响应式编程(例如RxJava)的方式实现 
2、对第三方依赖进行分类,每种依赖对应一个独立的线程/线程池
3、微服务不直接调用第三方依赖的API,而是使用异步封装之后的API接口
4、异步调用第三方依赖API之后,获取Future对象。利用响应式编程框架, 可以订阅后续的事件,接收响应,针对响应进行编程

七、微服务进程隔离(Docker容器)
关键技术点:
1、微服务独立开发、打包和部署
2、基于Docker部署微服务,可以实现细粒度的资源隔离,实现微服务的高密度部署。
优势:
1、高效:微服务的启动和销毁速度非常快, 可以实现秒级弹性伸缩
2、高性能:Docker容器的性能接近裸的物理机, 综合性能损耗 < 5%
3、可移植性:“一次编写,到处运行”

八、分布式路由容错
1、失败自动重试:微服务调用失败自动重试
2、失败自动切换:当发生服务调用异常时,重新选路,查找下一个可用的微服务提供者 
3、快速失败:对于一些非核心的服务,希望只调用一次,失败也不再重试
4、失败回调:提供异常回调接口,执行微服务消费者自定义的失败处理逻辑

九、服务降级
1、强制降级:不发起远程服务调用,执行本地降级策略,例如本地Mock方法 
2、容错降级:当非核心服务不可用时,可以对故障服务做业务逻辑放通,以￼￼保障核心服务的运行,降级策略包括异常转换、本地放通方法调用

十、熔断机制
1、熔断判断:微服务调用时, 对熔断开关状态进行判断,当熔断器开关关闭时, 请求被允许通过熔断器
2、熔断执行:当熔断器开关打 开时,微服务调用请求被禁止通过,执行失败回调接口
3、自动恢复:熔断之后,周期T 之后允许一条消息通过,如果成功,则取消熔断状态,否则继续处于熔断状态











	