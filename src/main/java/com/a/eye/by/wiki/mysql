一、Mysql主要存储引擎包括InnoDB、MyISAM
二、InnoDB和MyISAM的区别：
1、MyISAM不支持事物，表锁，支持全文检索，不支持外键，表空间相对比较小，关注的主要是查询的性能。
2、InnoDB支持事物，行锁，不支持全文检索，支持外检，表空间相对比较大，关注的是事务。
3、MyISAM的读性能比InnoDB强。
三、数值类型：
1、tinyint 1个字节
2、smallint 2个字节
3、mediumint 3个字节
4、int 4个字节
5、bigint 8个字节
6、float 4个字节
7、double 8个字节
8、bit 1-8个字节
四、日期类型
1、如果表示年月日用date
2、如果标示年月日时分秒，用datetime和timestamp
3、如果表示十分秒，用time
4、如果表示年，用year
五、datetime和timestamp的区别：
1、timestamp支持的时间范围比较小，从1970年到2038年的某个时间。
2、timestamp的查询和插入受当地时区的影响。
六、char、varchar、binary、varbinary、blob、text、enum和set
1、char的固定长度是0-255，且会去掉末尾的空格
2、varchar是非固定的，会保留末尾的空格
七、数据库隔离级别
1、数据库隔离级别包括：读未提交、读提交、重复读、序列化。
2、数据库各种隔离级别出现的问题：脏读、不可重复度、幻读
3、读未提交：脏读、不可重复读、幻读
4、读提交：不可重复读、幻读
5、重复度：幻读
6、序列化：不会出现问题
八、各种隔离级别出现的问题
1、脏读：一个事务读取了另外一个事务未提交的数据，而这个数据有可能回滚。
2、不可重复读：在访问数据库时，一个事务范围内的两次查询，返回了不同的结果。这是由于查询时系统中其他事务修改的提交而引起的。
3、幻读：是指事务不是独立执行时发生的一种现象。，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样.

九、小数类型为 decimal,禁止使用 float 和 double。
说明:float 和 double 在存储的时候,存在精度损失的问题,很可能在值的比较时,得到不 正确的结果。如果存储的数据范围超过 decimal 的范围,建议将数据拆成整数和小数分开存储。

十、如果存储的字符串长度几乎相等,使用 char 定长字符串类型。
varchar 是可变长字符串,不预先分配存储空间,长度不要超过 5000,如果存储长 度大于此值,定义字段类型为 text,独立出来一张表,用主键来对应,避免影响其它字段索 引效率。

十一、字段允许适当冗余,以提高性能,但是必须考虑数据同步的情况。冗余字段应遵循:
1)不是频繁修改的字段。
2)不是 varchar 超长字段,更不能是 text 字段。

十二、单表行数超过 500 万行或者单表容量超过 2GB,才推荐进行分库分表。 说明:如果预计三年后的数据量根本达不到这个级别,请不要在创建表时就分库分表。
十三、合适的字符存储长度,不但节约数据库表空间、节约索引存储,更重要的是提升检 索速度。

十四、业务上具有唯一特性的字段,即使是组合字段,也必须建成唯一索引。
说明:不要以为唯一索引影响了 insert 速度,这个速度损耗可以忽略,但提高查找速度是明 显的;另外,即使在应用层做了非常完善的校验和控制,只要没有唯一索引,根据墨菲定律, 必然有脏数据产生。

十五、超过三个表禁止 join。需要 join 的字段,数据类型保持绝对一致;多表关联查询 时,保证被关联的字段需要有索引。
说明:即使双表 join 也要注意表索引、SQL 性能。

十六、在 varchar 字段上建立索引时,必须指定索引长度,没必要对全字段建立索引,根据 实际文本区分度决定索引长度。 
说明:索引的长度与区分度是一对矛盾体,一般对字符串类型数据,长度为 20 的索引,区分 度会高达 90%以上,可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度 来确定。

十七、页面搜索严禁左模糊或者全模糊,如果需要请走搜索引擎来解决。 说明:索引文件具有 B-Tree 的最左前缀匹配特性,如果左边的值未确定,那么无法使用此索 引。
十八、如果有 order by 的场景,请注意利用索引的有序性。order by 最后的字段是组合 索引的一部分,并且放在索引组合顺序的最后,避免出现 file_sort 的情况,影响查询性能。 
正例:where a=? and b=? order by c; 索引:a_b_c 反例:索引中有范围查找,那么索引有序性无法利用,如:WHERE a>10 ORDER BY b; 索引 a_b 无法排序。

十九、利用覆盖索引来进行查询操作,来避免回表操作。
说明:如果一本书需要知道第 11 章是什么标题,会翻开第 11 章对应的那一页吗?目录浏览 一下就好,这个目录就是起到覆盖索引的作用。 
正例:能够建立索引的种类:主键索引、唯一索引、普通索引,而覆盖索引是一种查询的一种 效果,用explain的结果,extra列会出现:using index

二十、利用延迟关联或者子查询优化超多分页场景。
说明:MySQL 并不是跳过 offset 行,而是取 offset+N 行,然后返回放弃前 offset 行,返回 N 行,那当 offset 特别大的时候,效率就非常的低下,要么控制返回的总页数,要么对超过 特定阈值的页数进行 SQL 改写。
正例:先快速定位需要获取的 id 段,然后再关联:
SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id

二十一、SQL 性能优化的目标:至少要达到 range 级别,要求是 ref 级别,如果可以是 consts 最好。
说明:
1)consts 单表中最多只有一个匹配行(主键或者唯一索引),在优化阶段即可读取到数据。 2)ref 指的是使用普通的索引(normal index)。
3)range 对索引进行范围检索。
反例:explain 表的结果,type=index,索引物理文件全扫描,速度非常慢,这个 index 级 别比较 range 还低,与全表扫描是小巫见大巫。

二十二、建组合索引的时候,区分度最高的在最左边。
正例:如果 where a=? and b=? ,a 列的几乎接近于唯一值,那么只需要单建 idx_a 索引即 可。
说明:存在非等号和等号混合判断条件时,在建索引时,请把等号条件的列前置。如:where a>? and b=? 那么即使 a 的区分度更高,也必须把 b 放在索引的最前列。

二十三、创建索引时避免有如下极端误解:
1)误认为一个查询就需要建一个索引。 2)误认为索引会消耗空间、严重拖慢更新和新增速度。 3)误认为唯一索引一律需要在应用层通过“先查后插”方式解决。

二十四、count(*)会统计值为 NULL 的行,而 count(列名)不会统计此列为 NULL 值的行

二十五、当某一列的值全是 NULL 时,count(col)的返回结果为 0,但 sum(col)的返回结果为 NULL,因此使用 sum()时需注意 NPE 问题
正例:可以使用如下方式来避免sum的NPE问题:SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;

二十六、使用 ISNULL()来判断是否为 NULL 值。注意:NULL 与任何值的直接比较都为 NULL。 说明:
1) NULL<>NULL的返回结果是NULL,而不是false。 2) NULL=NULL的返回结果是NULL,而不是true。 3) NULL<>1的返回结果是NULL,而不是true。



