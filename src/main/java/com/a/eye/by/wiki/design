一、设计模式的六大原则：
1、开闭原则：对扩展开放，对修改关闭。为了程序可扩展、易于维护和升级，需要使用接口和抽象类。
2、里氏替换原则：任何基类出现的地方，子类一定可以出现。
3、依赖反转原则：针对接口编程，依赖抽象，不依赖具体。
4、接口隔离原则：使用多个隔离的接口，比使用单个接口要好。
5、迪米特法则（最少知道原则）：一个实体应该尽量少的和其他实体之间发生交互。
6、合成复用原则：尽量使用聚合，合成方式，而不是使用继承。
二、设计模式分类
1、创建型模式：工厂模式、抽象工厂模式、单例模式、建造者模式，原型模式。
2、结构型模式：适配器、装饰器、代理、外观、桥接、组合、享元模式
3、行为型模式：策略模式、模板方法、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介模式、解析器模式。
4、其他2种：并发型模式、线程池模式。
三、常见设计模式：
1、策略模式：定义了一系列算法，并将每个算法封装起来，使他们可以互相替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为
一系列实现类提供方法，多个实现类实现该接口。
2、模板方法：准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式展现，然后声明一些抽象方法来迫使子类实现剩余逻辑。不同的子类可以以不同
的逻辑来实现。
3、工厂方法：建立一个工厂类，对实现了同一个接口的一些类做实例化。
4、适配器模式：适配器模式将某个类的接口转换成希望的另外一个接口表示，目的是为了消除由于接口不匹配造成的兼容性问题。主要包括三类，类的适配器、
对象的适配模式、接口的适配模式。
类的适配器：有一个Source类，拥有一个方法，待适配，目标接口是Targetable，通过Adapter类，将Source的功能扩展到Targetable里。
对象的适配器：基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。
接口的适配器：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，
有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，
只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行
5、装饰模式：装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例
6、代理模式：代理模式就是多一个代理类出来，替原对象进行一些操作

四、面向对象的五大基本原则(solid)
1、S单一职责SRP:Single-Responsibility Principle 一个类,最好只做一件事,只有一个引起它的变化。单一职责原则可以看做是低耦合,高内聚在面向对象原则的引申,将职责定义为引起变化的原因,以提高内聚性减少引起变化的原因。
2、O开放封闭原则OCP:Open-Closed Principle 软件实体应该是可扩展的,而不是可修改的。对扩展开放,对修改封闭
3、L里氏替换原则LSP:Liskov-Substitution Principle 子类必须能够替换其基类。这一思想表现为对继承机制的约束规范,只有子类能够替换其基类时,才能够保证系统在运行期内识别子类,这是保证继承复用的基础。
4、I接口隔离原则ISP:Interface-Segregation Principle 使用多个小的接口,而不是一个大的总接口
5、D依赖倒置原则DIP:Dependency-Inversion Principle 依赖于抽象。具体而言就是高层模块不依赖于底层模块,二者共同依赖于抽象。抽象不依赖于具体,具体依赖于抽象。









