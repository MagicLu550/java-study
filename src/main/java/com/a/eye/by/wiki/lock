1、Lock能完成几乎所有synchronized的功能，并有一些后者不具备的功能，如锁投票、定时锁等候、可中断锁等候等。
2、synchronized 是Java 语言层面的，是内置的关键字；Lock 则是JDK 5中出现的一个包，在使用时，synchronized 同步的代码块可以由JVM自动释放；Lock 需要程序员在finally块中手工释放，如果不释放，可能会引起难以预料的后果
二、主内存和工作内存：
1、Java内存模型中规定了所有的变量都存储在主内存中，每个线程还有自己的工作内存，线程的工作内存，保存了该线程使用到的主内存副本拷贝，线程对变量的所有操作必须在工作内存中，而不能直接读写主内存中的变量，
不同线程之间无法直接访问对方工作内存中的变量，线程间值的传递均需要通过主内存来完成。
三、什么是自旋锁：
自旋锁jdk1.6后默认自动开启，基于之前的观察，共享数据的锁定状态只会持续很短的时间，为了这一段时间而去挂起和恢复线程有点浪费，然后面请求锁的那个线程稍等一会，但是不放弃处理器的执行时间，看看只有线程的锁
是否能很快释放。为了让线程等待，所以需要让线程执行一个忙循环自旋操作。
四、锁消除
虚拟机即使编译器在运行时，对于代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。如果判断一段代码，在堆上的数据都不会逃逸，被其他线程访问到，那么认为是线程私有的，同步加锁也就没有必要了。
五、锁粗化
原则上，在编写代码时，推荐将同步块的作用范围限制的尽量小，仅仅在共享数据的实际作用域才进行同步，这样目的是使得需要同步的操作尽可能小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。但是如果一系列的连续
操作都对同一个对象反复加锁和解锁，甚至锁出现在循环体内，及时没有线程竞争，频繁的进行互斥操作也会带来性能损耗。
六、偏向锁
偏向锁意思是这个锁会偏向第一个获取它的线程，如果在接下来的过程中，该锁没有被其他线程获取，则只有偏向锁的线程将永远不需要进行同步，偏向锁可以提高带有同步但是没有竞争的程序的性能。偏向锁也不一定总是对程序
有利的，如果程序中的锁大部分都是被多个不同的线程访问，那么偏向模式就是多余的。
