1、Lock能完成几乎所有synchronized的功能，并有一些后者不具备的功能，如锁投票、定时锁等候、可中断锁等候等。
2、synchronized 是Java 语言层面的，是内置的关键字；Lock 则是JDK 5中出现的一个包，在使用时，synchronized 同步的代码块可以由JVM自动释放；Lock 需要程序员在finally块中手工释放，如果不释放，可能会引起难以预料的后果
二、主内存和工作内存：
1、Java内存模型中规定了所有的变量都存储在主内存中，每个线程还有自己的工作内存，线程的工作内存，保存了该线程使用到的主内存副本拷贝，线程对变量的所有操作必须在工作内存中，而不能直接读写主内存中的变量，
不同线程之间无法直接访问对方工作内存中的变量，线程间值的传递均需要通过主内存来完成。
三、什么是自旋锁：
自旋锁jdk1.6后默认自动开启，基于之前的观察，共享数据的锁定状态只会持续很短的时间，为了这一段时间而去挂起和恢复线程有点浪费，然后面请求锁的那个线程稍等一会，但是不放弃处理器的执行时间，看看只有线程的锁
是否能很快释放。为了让线程等待，所以需要让线程执行一个忙循环自旋操作。
四、锁消除
虚拟机即使编译器在运行时，对于代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。如果判断一段代码，在堆上的数据都不会逃逸，被其他线程访问到，那么认为是线程私有的，同步加锁也就没有必要了。