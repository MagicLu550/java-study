六十六、同步访问共享的可变数据
1、为了在线程之间进行可靠的通信，也为了互斥访问，同步是必要的。
2、当多个线程共享可变数据的时候，每个读或者写数据的线程都必须执行同步。

六十七、避免过度同步
1、应该在同步区域内做尽可能少的工作
为了避免死锁和数据破坏，千万不要从同步区域内部调用外来方法，要尽量限制同步区域内部的工作量。当你在设计一个不可变的类时，要考虑是否应该自己完成同步
操作，现在这个多核时代，永远不要过度同步来得更重要。

六十八、executor和task优先于线程

六十九、并发工具优先wait和notify

七十、线程安全的文档化
线程安全的几种级别：
1、不可变对象，这个类的实例不可变。不需要外部的同步，例如String、Long和BigInteger
2、无条件的线程安全，这个类的实例是可变的，但是这个累有着足够的内部同步。
3、有条件的线程安全，
4、非线程安全
5、线程对立

七十一、谨慎的使用延迟初始化
1、大多数情况下，正常的初始化要优先余延迟初始化
2、如果用延迟优化来破坏初始化的循环，就要使用同步方法
3、如果出于对性能的考虑需要对静态域使用延迟初始化，就使用lazy initialization holder class模式，静态内部类
4、如果出于性能的考虑而需要对实例域使用延迟初始化，就使用双重检测模式
5、对于静态域，如果可以接受重复初始化的实例域，可以考虑使用单重检测模式

七十二、不要依赖线程调度器
1、任何依赖于线程调度器来达到正确性或者性能要求的程序，很有可能都是不可移植的

七十三、避免使用线程组
线程组没有提供太多有用的功能，而且很多功能还有缺陷。











































