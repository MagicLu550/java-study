一、判断对象是否已死？
1、引用计数法：给对象添加一个引用计数器，当对象被引用，加1，引用失效，减1，计数器的值为0，那么可以回收。缺陷：当2个对象相互引用时，导致2个计数器的值都不为0。
2、可达性分析：Gc roots。Gc roots包括的对象有 1 虚拟机栈中引用的对象。方法区中静态属性引用的对象，方法区中常量方法引用的对象。本地方法栈中，引用的对象。
3、引用包括，强引用、软引用、弱引用、虚引用。强引用：对象被引用不能被回收。软引用：用来描述一些还有用但是并非必须的对象。当系统将要发生内存溢出的时候，将会把这些对象进行第二次回收。弱引用：弱引用用来描述非必须对系那个，但是它的强度比软引用更弱一些，被弱引用的对象只能生存到下一次垃圾搜集发生之前。无论内存是否足够都会被回收。虚引用：虚引用也被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。为对象设置一个虚引用唯一的目的就是能在这个对象被回收时收到一个系统通知。
二、java的类被回收的条件：
1、该类所有的实例都已经被回收，java堆中不存在该类的任何实例。
2、加载该类的classloader已经被回收。
3、该类对应的java.lang.class对象没有任何地方被引用。
一、基本回收算法
    1：引用计数：比较古老的回收算法。原理是此对象有一个引用，即增加一个技术，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法时致命的是无法处理循环引用的问题。
    2：标记-清除：此算法执行分为两个阶段。第一个阶段从引用根节点开始标记所有被引用的对象；第二个阶段便利整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。
    3：复制：此算法把内存空间划分为两个相同的区域，每次只是用其中的一个区域。垃圾回收时，便利当前使用区域，把正在使用中的对象复制到另外一个区域。此算法每次只处理正在使用中的对象，因此复制成本比较小，同事复制过去以后还能进行相应的内存整理，不过会出现碎片问题。当然，此算法的缺点也是很明显的，就是需要两倍的内存。
    4：标记-整理：此算法结合了“标记-清除"和"复制"两个算法的有点。也是分两个阶段，第一个阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象"压缩"到堆的其中一块，按顺序排放。此算法避免了"标记-清除"碎片问题，同时也避免了复制算法的空间问题。
    5：增量收集：实施垃圾回收算法，即应用进行的同时进行垃圾回收。
    6：分代算法：基于对象生命周期分析后得出的垃圾回收算法。把对象分为年轻代、年老带、持久代，对不同生命周期的对象使用不同的算法进行回收。
三、SavePoint安全点和安全区
1、程序执行时并非所有的地方都能停顿下来开始GC，只有到达安全点才能停顿。SafePoint的选定既不讷讷个太少导致让GC等待时间太长，也不能过于频繁已至过分增加运行的负荷。安全点的选定基本上是已"是否具有让程序长时间执行的特征"为标准进行选定的。
2、让所有的线程到达安全的方案有2中：抢先式终端，和主动式中断。抢先式中断：不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有的线程不在安全点上，就恢复线程，让它跑到安全点。主动式中断：当GC需要中断时，仅仅简单地这只一个标识，各个线程执行时主动去轮训这个标志。发现终端标志为真时，就将自己挂起。
3、安全区：在一段代码片段中，引用关系不会发生变化，在这个区域的任意地方开始GC都是安全的。例如，有些时候是程序不执行的时候，当线程处于Sleep状态或者Blocked状态，无法响应jvm的中段请求。当线程进入安全区以后，会标识自己已经进入安全区，当jvm要发起gc时，就不用管标识自己为safe region状态的线程了。
四、垃圾收集器
1、Serial收集器
Serial收集器是一个单线程收集器，它在进行垃圾回收时，需要stop the world。
2、ParNew收集器
ParNew收集器是Serial的多线程版本。是Server模式下新生代默认的收集器，目前除了Serial收集器外只有它能与CMS收集器配合使用。
3、Parallel Scavenge收集器
是一款新生代收集器，它采用赋值算法，又是并行的多线程收集器。主要关注的是吞吐量。吞吐量=用户代码执行时间/用户代码执行时间+垃圾回收时间。Parallel Scavenge收集器提供了两个参数用于青雀控制吞吐量，分别是控制最大垃圾手机停顿时间和直接设置吞吐量大小的参数。
4、Serial Old收集器
Serial Old是Serial的老年代版本，同样是单线程收集器。主要作用是作为CMS收集器的备用方案。
5、Parallel Old收集器
Parallel Old收集器是 Parallel Scavenge的老年代版本，使用的是多线程和标记-整理算法。
6、CMS收集器
CMS：Concurrent Mark Sweep 收集器是一种以获取最短回收停顿时间为目的的收集器。CMS收集器是给予标记-清除算法实现的整个过程包括4个步骤：1初始标记2、并发标记、3、重新标记、4并发清除。CMS的有点是并发收集、低停顿。
7、G1收集器
分代概念在G1中仍然得已保留。G1从整体来看是给予标记整理算法实现的收集器、从局部上来看是给予复制算法实现的。G1在运作期间不会出现内存空间碎片，收集后能提供规整的可用内存。有利于程序长时间运行，分配大对象。
