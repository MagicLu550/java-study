一、判断对象是否已死？
1、引用计数法：给对象添加一个引用计数器，当对象被引用，加1，引用失效，减1，计数器的值为0，那么可以回收。缺陷：当2个对象相互引用时，导致2个计数器的值都不为0。
2、可达性分析：Gc roots。Gc roots包括的对象有 1 虚拟机栈中引用的对象。方法区中静态属性引用的对象，方法区中常量方法引用的对象。本地方法栈中，引用的对象。
3、引用包括，强引用、软引用、弱引用、虚引用。强引用：对象被引用不能被回收。软引用：用来描述一些还有用但是并非必须的对象。当系统将要发生内存溢出的时候，将会把这些对象进行第二次回收。弱引用：弱引用用来描述非必须对系那个，但是它的强度比软引用更弱一些，被弱引用的对象只能生存到下一次垃圾搜集发生之前。无论内存是否足够都会被回收。虚引用：虚引用也被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。为对象设置一个虚引用唯一的目的就是能在这个对象被回收时收到一个系统通知。
二、java的类被回收的条件：
1、该类所有的实例都已经被回收，java堆中不存在该类的任何实例。
2、加载该类的classloader已经被回收。
3、该类对应的java.lang.class对象没有任何地方被引用。
一、基本回收算法
    1：引用计数：比较古老的回收算法。原理是此对象有一个引用，即增加一个技术，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法时致命的是无法处理循环引用的问题。
    2：标记-清除：此算法执行分为两个阶段。第一个阶段从引用根节点开始标记所有被引用的对象；第二个阶段便利整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。
    3：复制：此算法把内存空间划分为两个相同的区域，每次只是用其中的一个区域。垃圾回收时，便利当前使用区域，把正在使用中的对象复制到另外一个区域。此算法每次只处理正在使用中的对象，因此复制成本比较小，同事复制过去以后还能进行相应的内存整理，不过会出现碎片问题。当然，此算法的缺点也是很明显的，就是需要两倍的内存。
    4：标记-整理：此算法结合了“标记-清除"和"复制"两个算法的有点。也是分两个阶段，第一个阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象"压缩"到堆的其中一块，按顺序排放。此算法避免了"标记-清除"碎片问题，同时也避免了复制算法的空间问题。
    5：增量收集：实施垃圾回收算法，即应用进行的同时进行垃圾回收。
    6：分代算法：基于对象生命周期分析后得出的垃圾回收算法。把对象分为年轻代、年老带、持久代，对不同生命周期的对象使用不同的算法进行回收。