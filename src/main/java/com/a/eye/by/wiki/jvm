一、判断对象是否已死？
1、引用计数法：给对象添加一个引用计数器，当对象被引用，加1，引用失效，减1，计数器的值为0，那么可以回收。缺陷：当2个对象相互引用时，导致2个计数器的值都不为0。
2、可达性分析：Gc roots。Gc roots包括的对象有 1 虚拟机栈中引用的对象。方法区中静态属性引用的对象，方法区中常量方法引用的对象。本地方法栈中，引用的对象。
3、引用包括，强引用、软引用、弱引用、虚引用。强引用：对象被引用不能被回收。软引用：用来描述一些还有用但是并非必须的对象。当系统将要发生内存溢出的时候，将会把这些对象进行第二次回收。弱引用：弱引用用来描述非必须对系那个，但是它的强度比软引用更弱一些，被弱引用的对象只能生存到下一次垃圾搜集发生之前。无论内存是否足够都会被回收。虚引用：虚引用也被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。为对象设置一个虚引用唯一的目的就是能在这个对象被回收时收到一个系统通知。
二、java的类被回收的条件：
1、该类所有的实例都已经被回收，java堆中不存在该类的任何实例。
2、加载该类的classloader已经被回收。
3、该类对应的java.lang.class对象没有任何地方被引用。
一、基本回收算法
    1：引用计数：比较古老的回收算法。原理是此对象有一个引用，即增加一个技术，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法时致命的是无法处理循环引用的问题。
    2：标记-清除：此算法执行分为两个阶段。第一个阶段从引用根节点开始标记所有被引用的对象；第二个阶段便利整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。
    3：复制：此算法把内存空间划分为两个相同的区域，每次只是用其中的一个区域。垃圾回收时，便利当前使用区域，把正在使用中的对象复制到另外一个区域。此算法每次只处理正在使用中的对象，因此复制成本比较小，同事复制过去以后还能进行相应的内存整理，不过会出现碎片问题。当然，此算法的缺点也是很明显的，就是需要两倍的内存。
    4：标记-整理：此算法结合了“标记-清除"和"复制"两个算法的有点。也是分两个阶段，第一个阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象"压缩"到堆的其中一块，按顺序排放。此算法避免了"标记-清除"碎片问题，同时也避免了复制算法的空间问题。
    5：增量收集：实施垃圾回收算法，即应用进行的同时进行垃圾回收。
    6：分代算法：基于对象生命周期分析后得出的垃圾回收算法。把对象分为年轻代、年老带、持久代，对不同生命周期的对象使用不同的算法进行回收。
三、SavePoint安全点和安全区
1、程序执行时并非所有的地方都能停顿下来开始GC，只有到达安全点才能停顿。SafePoint的选定既不讷讷个太少导致让GC等待时间太长，也不能过于频繁已至过分增加运行的负荷。安全点的选定基本上是已"是否具有让程序长时间执行的特征"为标准进行选定的。
2、让所有的线程到达安全的方案有2中：抢先式终端，和主动式中断。抢先式中断：不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有的线程不在安全点上，就恢复线程，让它跑到安全点。主动式中断：当GC需要中断时，仅仅简单地这只一个标识，各个线程执行时主动去轮训这个标志。发现终端标志为真时，就将自己挂起。
3、安全区：在一段代码片段中，引用关系不会发生变化，在这个区域的任意地方开始GC都是安全的。例如，有些时候是程序不执行的时候，当线程处于Sleep状态或者Blocked状态，无法响应jvm的中段请求。当线程进入安全区以后，会标识自己已经进入安全区，当jvm要发起gc时，就不用管标识自己为safe region状态的线程了。
四、垃圾收集器
1、Serial收集器
Serial收集器是一个单线程收集器，它在进行垃圾回收时，需要stop the world。
2、ParNew收集器
ParNew收集器是Serial的多线程版本。是Server模式下新生代默认的收集器，目前除了Serial收集器外只有它能与CMS收集器配合使用。
3、Parallel Scavenge收集器
是一款新生代收集器，它采用赋值算法，又是并行的多线程收集器。主要关注的是吞吐量。吞吐量=用户代码执行时间/用户代码执行时间+垃圾回收时间。Parallel Scavenge收集器提供了两个参数用于青雀控制吞吐量，分别是控制最大垃圾手机停顿时间和直接设置吞吐量大小的参数。
4、Serial Old收集器
Serial Old是Serial的老年代版本，同样是单线程收集器。主要作用是作为CMS收集器的备用方案。
5、Parallel Old收集器
Parallel Old收集器是 Parallel Scavenge的老年代版本，使用的是多线程和标记-整理算法。
6、CMS收集器
CMS：Concurrent Mark Sweep 收集器是一种以获取最短回收停顿时间为目的的收集器。CMS收集器是给予标记-清除算法实现的整个过程包括4个步骤：1初始标记2、并发标记、3、重新标记、4并发清除。CMS的有点是并发收集、低停顿。
7、G1收集器
分代概念在G1中仍然得已保留。G1从整体来看是给予标记整理算法实现的收集器、从局部上来看是给予复制算法实现的。G1在运作期间不会出现内存空间碎片，收集后能提供规整的可用内存。有利于程序长时间运行，分配大对象。
可预测的停顿，这是G1与CMS的另一大优势。降低停顿时间是G1和CMS共同关注点。G1除了追求低停顿外，还能建立可预测的停顿时间模型。能够让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾回收的时间不能超过N秒。G1跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先级列表。根据每次允许的收集时间，优先回收价值最大的Resion。G1收集器运作的步骤包括：初始标记、并发标记、最终标记、筛选回收。

五、JVM中并行与并发的区别
1、并行：指多条垃圾收集线程并行狗牯脑做，但此时用户线程仍然处于等待状态。
2、并发：指用户线程与垃圾搜集线程同事执行，单不一定是并行，可能是交替执行。

一、基本回收算法
    1：引用计数：比较古老的回收算法。原理是此对象有一个引用，即增加一个技术，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法时致命的是无法处理循环引用的问题。
    2：标记-清除：此算法执行分为两个阶段。第一个阶段从引用根节点开始标记所有被引用的对象；第二个阶段便利整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。
    3：复制：此算法把内存空间划分为两个相同的区域，每次只是用其中的一个区域。垃圾回收时，便利当前使用区域，把正在使用中的对象复制到另外一个区域。此算法每次只处理正在使用中的对象，因此复制成本比较小，同事复制过去以后还能进行相应的内存整理，不过会出现碎片问题。当然，此算法的缺点也是很明显的，就是需要两倍的内存。
    4：标记-整理：此算法结合了“标记-清除"和"复制"两个算法的有点。也是分两个阶段，第一个阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象"压缩"到堆的其中一块，按顺序排放。此算法避免了"标记-清除"碎片问题，同时也避免了复制算法的空间问题。
    5：增量收集：实施垃圾回收算法，即应用进行的同时进行垃圾回收。
    6：分代算法：基于对象生命周期分析后得出的垃圾回收算法。把对象分为年轻代、年老带、持久代，对不同生命周期的对象使用不同的算法进行回收。
二、基于分代算法
    1、年轻代：年轻代分为三个区。一个Eden区，两个Survivor区。大部分对象都是在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活对象被复制到另外一个Survivor区，当这个Survivor区也满了时，会从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到老年代。需要注意的是Survivor区是对称的，没有先后关系，所以同一个区中可能同时存在从Eden复制过来的对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor过来的对象。而且Survivor总有一个是空的。
    2、年老代：年老代存放从年轻带存货的对象。一般来说年老代都是存放生命周期较长的对象。
    3、持久代：用于存放静态文件，例如java类、方法等。持久代对垃圾回收没有显著的影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程总新增的类。持久代大小通过-XX：MAXPermSize进行设置。

六、java运行时数据区域：
1、程序计数器：当前线程所执行的字节码的行号指示器。
2、虚拟机栈：是线程私有的，它的生命周期和线程相同，每个方法在执行的时候会创建一个栈帧，用于存储变量表、操作数栈、方法出口、动态连接等。
3、本地方法区：本地方法栈是为虚拟机使用到的native方法服务。
4、堆：是java虚拟机所管理的内存中最大的一块。java堆是所有线程共享的一块内存区域，目的是为了存放对象实例。
5、方法区：方法区也是各个线程共享的一块区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译后的代码等。









