一、简介
1：任何一个Class文件都对应唯一一个类或者接口的定义信息。Class文件是一组8位字节码为基础单位的二进制流，各个项目岩哥按照顺序紧凑的排列在Class文件中，中间没有添加任何的分隔符，Class文件存储的几乎是全部的必要数据。
2：Class文件格式采用二中类型数据：无符号数和表。无符号数：无符号数属于基本数据类型，用来描述数字、索引引用、数量值或者按照UTF-8编码组成的字符串。表：是由多个无符号数或者其他表作为数据项构成的符合数据类型，所有的表都习惯性的以"_info"结尾。
3：每个Class文件的头4个字节成为"魔数"，它的唯一作用就是确定这个文件是否为一个能够被虚拟机接受的Class文件，很多文件存储标准中都使用魔数来进行身份识别。
4：Class文件的魔数值为oxCAFEBABE
二、类的加载时机
1、类从加载到虚拟机内存开始，到卸载出内存位置。它的生命周期包括：加载、连接、初始化、使用、卸载。连接：验证、准备、解析。
三、类的初始化
1、遇到new、getstatic、putstatic或invokestatic这4条字节码指令的时候，如果类没有初始化，则需要初始化。new创建一个对象，获取或者设置静态属性、调用静态方法时，需要初始化。
2、使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。
3、当初始化一个类的时候，发现其父类没有初始化，则需要先触发其父类的初始化。
4、当使用jdk7动态语言支持时，有些方法句柄对应的类，没有进行初始化，需要触发其初始化。
四、类的加载过程
1、在加载阶段，虚拟机需要完成一下3件事情，1：通过一个类的权限名来获取定义此类的二进制字节流。
2：将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构。3：在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
五、类加载过程：
1、加载：查找和导入class文件
2、连接：
  2.1：验证：检查载入Class文件是否符合JVM规范。
  2.2：准备：将静态变量分配存储空间。
  2.3：解析：将符号引用，转换成直接引用。
3、初始化：对类的静态变量，静态代码块初始化操作。
六、类的加载过程：
1、类的主动引用（一定会发生类的初始化）
1.1 new一个类的对象
1.2 调用一个类的静态成员或者静态方法
1.3 使用反射方法对类进行反射调用
1.4 启动main方法所在的类
1.5 当初始化一个类时，其父类如果没有被初始化，则先初始化父类
2、类的被动引用（不会发生类的初始化）
2.1 当访问一个静态域时，只有真正声明的这个类才会被初始化
	通过子类引用父类的静态变量，子类不会被初始化
2.2 通过数组定义引用类，不会触发类的初始化
2.3 引用常量不会触发此类的初始化
七、类加载器的代理模式：
1、代理模式：交给其他加载器来加载指定的类
2、双亲委托机制：在加载类时，首先将加载任务交给父类加载器加载。双亲委托机制是为了保证java核心类库的类型安全。
八、类加载器的层次结构：
1、引导类加载器（根加载器）
2、扩展类加载器
3、应用程序加载器
4、自定义加载器
九、线程上下文加载器：
1、当需要动态加载资源的时候，你至少有三个classloader可以选择：
1.1系统类加载器叫做应用加载器
1.2当前类加载器
1.3当前线程加载器
1.4线程类加载器是为了抛弃双亲委派加载链模式
每个线程都有一个关联的上下文类加载器。如果使用new Thread方式生成新的线程，新线程将继承父线程的上下文加载器














